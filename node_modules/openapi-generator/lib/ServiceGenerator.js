"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const debug = require('debug')('openapi-generator');
const fs = require("fs");
const path = require("path");
const nunjucks = require("nunjucks");
const util_1 = require("./util");
class GenConfig {
    constructor() {
        /** 生成请求库 */
        this.requestLib = true;
        /** filename style, true 为大驼峰，lower 为小驼峰 */
        this.camelCase = false;
        /** gen type */
        this.type = 'ts';
        /** 生成 Service 类型 */
        this.serviceType = 'function';
        /** 复杂类型命名空间 */
        this.namespace = 'API';
        /** 数据处理钩子 */
        this.hook = {};
    }
}
exports.GenConfig = GenConfig;
class ServiceGenerator {
    constructor(config, openAPIData) {
        this.config = config;
        this.openAPIData = openAPIData;
        this.apiData = {};
        Object.keys(openAPIData.paths || {}).forEach(path => {
            const pathItem = openAPIData.paths[path];
            ['get', 'put', 'post', 'delete'].forEach(method => {
                const operationObject = pathItem[method];
                if (operationObject) {
                    operationObject.tags.forEach(tag => {
                        if (!this.apiData[tag]) {
                            this.apiData[tag] = [];
                        }
                        this.apiData[tag].push(Object.assign({ path,
                            method }, operationObject));
                    });
                }
            });
        });
    }
    genFile() {
        this.genRequestLib();
        if (this.config.type === 'ts') {
            debug('[GenSDK] gen interface.');
            this.genFileFromTemplate('typings.d.ts', 'interface', {
                namespace: this.config.namespace,
                list: this.getInterfaceTP(),
            });
        }
        this.getServiceTP()
            .filter(tp => {
            tp.list = tp.list.filter(item => !this.config.filter ||
                this.config.filter.some(f => {
                    return f instanceof RegExp
                        ? f.test(item.path)
                        : typeof f === 'function'
                            ? f(item)
                            : true;
                }));
            return tp.list.length;
        })
            .map(tp => {
            debug('[GenSDK] generate service:', tp.className);
            this.genFileFromTemplate(this.getFinalFileName(`${tp.className}.${this.config.type}`), 'service', Object.assign({ namespace: this.config.namespace }, tp));
        });
    }
    genRequestLib() {
        if (this.config.requestLib) {
            this.mkdir(this.config.sdkDir);
            const reqLibPath = path.join(this.config.sdkDir, `base.${this.config.type}`);
            if (!fs.existsSync(reqLibPath)) {
                fs.writeFileSync(reqLibPath, nunjucks.renderString(fs.readFileSync(path.join(__dirname, 'template', 'base.njk'), 'utf8'), { genType: this.config.type }), 'utf8');
            }
        }
    }
    getInterfaceTP() {
        const components = this.openAPIData.components;
        const data = [components.schemas].map(defines => {
            return Object.keys(defines).map(typeName => {
                try {
                    const props = this.resolveRefObject(defines[typeName]);
                    if (props.type !== 'object') {
                        throw new util_1.CommonError(`Unsupported interface type: ${typeName}: ${props.type}`);
                    }
                    const requiredPropKeys = props.required || [];
                    const propsData = props.properties
                        ? Object.keys(props.properties).map(propName => {
                            const propSchema = props.properties[propName];
                            return Object.assign({}, propSchema, { name: propName, type: this.getType(propSchema), desc: [propSchema.title, propSchema.description].filter(s => s).join(' '), required: requiredPropKeys.some(key => key === propName) });
                        })
                        : [];
                    if (props.additionalProperties) {
                        if (props.additionalProperties === true) {
                            propsData.push({
                                name: '[key: string]',
                                type: 'any',
                                desc: '',
                                required: true,
                            });
                        }
                        else {
                            propsData.push({
                                name: '[key: string]',
                                type: this.getType(props.additionalProperties),
                                desc: props.additionalProperties.description,
                                required: true,
                            });
                        }
                    }
                    return {
                        typeName,
                        type: this.getType(props),
                        props: propsData,
                    };
                }
                catch (error) {
                    console.warn('[GenSDK] gen interface param error:', error);
                    throw error;
                }
            });
        });
        return data.reduce((p, c) => p.concat(c), []);
    }
    getServiceTP() {
        return Object.keys(this.apiData).map(tag => {
            // functionName tag级别防重
            const tmpFunctionRD = {};
            const genParams = this.apiData[tag]
                .filter(api => {
                // 暂不支持变量
                return !api.path.includes('${');
            })
                .map(api => {
                try {
                    const params = this.getParamsTP(api.parameters);
                    const body = this.getBodyTP(api.requestBody);
                    const response = this.getResponseTP(api.responses);
                    let functionName = this.config.hook.customFunctionName
                        ? this.config.hook.customFunctionName(api)
                        : api.operationId;
                    if (tmpFunctionRD[functionName]) {
                        functionName = `${functionName}_${tmpFunctionRD[functionName]++}`;
                    }
                    else {
                        tmpFunctionRD[functionName] = 1;
                    }
                    return Object.assign({}, api, { functionName, path: api.path.replace(/{([^}]*)}/gi, ({}, str) => {
                            return `\$\{${str}\}`;
                        }), method: api.method, desc: [api.summary, api.description].filter(s => s).join(' '), hasHeader: !!(params && params.header) || !!(body && body.mediaType), params,
                        body,
                        response });
                }
                catch (error) {
                    console.warn('[GenSDK] gen service param error:', error);
                    throw error;
                }
            });
            const className = this.config.hook.customClassName
                ? this.config.hook.customClassName(tag)
                : this.toCamelCase(tag);
            return {
                genType: this.config.type,
                className,
                instanceName: `${className[0].toLowerCase()}${className.substr(1)}`,
                list: genParams,
            };
        });
    }
    getBodyTP(requestBody) {
        const reqBody = this.resolveRefObject(requestBody);
        if (!reqBody) {
            return;
        }
        const reqContent = reqBody.content;
        if (typeof reqContent !== 'object') {
            return;
        }
        const mediaType = Object.keys(reqContent)[0];
        const schema = reqContent[mediaType].schema;
        if (schema.type === 'object' && schema.properties) {
            return Object.assign({ mediaType }, schema, { propertiesList: Object.keys(schema.properties).map(p => ({
                    key: p,
                    schema: Object.assign({}, schema.properties[p], { type: this.getType(schema.properties[p], this.config.namespace) }),
                })) });
        }
        return {
            mediaType,
            type: this.getType(schema, this.config.namespace),
        };
    }
    getResponseTP(responses) {
        const response = this.resolveRefObject(responses.default || responses['200']);
        const defaultResponse = {
            mediaType: '*/*',
            type: 'any',
        };
        if (!response) {
            return defaultResponse;
        }
        const resContent = response.content;
        if (typeof resContent !== 'object') {
            return defaultResponse;
        }
        const mediaType = Object.keys(resContent)[0];
        const schema = resContent[mediaType].schema;
        return {
            mediaType,
            type: this.getType(schema, this.config.namespace),
        };
    }
    getParamsTP(parameters) {
        if (!parameters || !parameters.length) {
            return;
        }
        const templateParams = {};
        ['query', 'header', 'path', 'cookie'].forEach(source => {
            const params = parameters
                .map(p => this.resolveRefObject(p))
                .filter((p) => p.in === source)
                .map(p => (Object.assign({}, p, { type: this.getType(p.schema, this.config.namespace) })));
            if (params.length) {
                templateParams[source] = params;
            }
        });
        return templateParams;
    }
    genFileFromTemplate(fileName, type, params) {
        try {
            const template = this.getTemplate(type);
            this.writeFile(fileName, nunjucks.renderString(template, params));
        }
        catch (error) {
            console.warn('[GenSDK] file gen fail:', fileName, 'type:', type);
            throw error;
        }
    }
    writeFile(fileName, content) {
        const filePath = path.join(this.config.sdkDir, fileName);
        this.mkdir(path.dirname(filePath));
        fs.writeFileSync(filePath, content, { encoding: 'utf8' });
    }
    getTemplate(type) {
        const configFilePath = type === 'interface' ? this.config.interfaceTemplatePath : this.config.templatePath;
        try {
            if (configFilePath) {
                this.mkdir(path.dirname(configFilePath));
                if (fs.existsSync(configFilePath)) {
                    return fs.readFileSync(configFilePath, 'utf8');
                }
            }
            const fileContent = fs.readFileSync(path.join(__dirname, 'template', type === 'service' ? `${type}.${this.config.serviceType}.njk` : `${type}.njk`), 'utf8');
            if (configFilePath) {
                fs.writeFileSync(configFilePath, fileContent, 'utf8');
            }
            return fileContent;
        }
        catch (error) {
            console.warn(`[GenSDK] get {${type}} template fail:`, configFilePath);
            throw error;
        }
    }
    resolveRefObject(refObject) {
        if (!refObject || !refObject.$ref) {
            return refObject;
        }
        const refPaths = refObject.$ref.split('/');
        if (refPaths[0] === '#') {
            refPaths.shift();
            let obj = this.openAPIData;
            refPaths.forEach((node) => {
                obj = obj[node];
            });
            if (!obj) {
                throw new Error(`[GenSDK] Data Error! Notfoud: ${refObject.$ref}`);
            }
            return obj.$ref ? this.resolveRefObject(obj) : obj;
        }
    }
    getRefName(refObject) {
        if (typeof refObject !== 'object' || !refObject.$ref) {
            return refObject;
        }
        const refPaths = refObject.$ref.split('/');
        return refPaths[refPaths.length - 1];
    }
    mkdir(dir) {
        if (!fs.existsSync(dir)) {
            this.mkdir(path.dirname(dir));
            fs.mkdirSync(dir);
        }
    }
    getFinalFileName(fileName) {
        if (this.config.camelCase === true) {
            return this.toCamelCase(fileName);
        }
        else if (this.config.camelCase === 'lower') {
            fileName = this.toCamelCase(fileName);
            return `${fileName[0].toLowerCase()}${fileName.substr(1)}`;
        }
        return this.toHyphenCase(fileName);
    }
    toHyphenCase(s) {
        s = s.replace(/([A-Z])/g, '_$1').toLowerCase();
        if (s.startsWith('_')) {
            s = s.substr(1);
        }
        return s;
    }
    toCamelCase(s) {
        return s.replace(/_(\w)/g, function (_all, letter) {
            return letter.toUpperCase();
        });
    }
    getType(schemaObject, namespace = '') {
        if (!schemaObject) {
            return 'any';
        }
        if (typeof schemaObject !== 'object') {
            return schemaObject;
        }
        if (schemaObject.$ref) {
            return [namespace, this.getRefName(schemaObject)].filter(s => s).join('.');
        }
        let type = schemaObject.type;
        switch (schemaObject.format) {
            case 'float':
            case 'double':
            case 'int32':
            case 'int64':
                type = 'number';
                break;
        }
        if (schemaObject.enum) {
            type = 'enum';
        }
        switch (type) {
            case 'number':
            case 'int':
            case 'integer':
            case 'long':
            case 'float':
            case 'double':
                return 'number';
            case 'Date':
            case 'date':
            case 'dateTime':
            case 'date-time':
            case 'datetime':
                return 'Date';
            case 'string':
            case 'email':
            case 'password':
            case 'url':
            case 'byte':
            case 'binary':
                return 'string';
            case 'boolean':
                return 'boolean';
            case 'array':
                const str = this.getType(schemaObject.items, namespace);
                return `${['|', '&'].some(sep => str.includes(sep)) ? `(${str})` : str}[]`;
            /** 以下非标准 */
            case 'enum':
                return Array.isArray(schemaObject.enum)
                    ? Array.from(new Set(schemaObject.enum.map(v => typeof v === 'string' ? `"${v.replace(/"/g, '"')}"` : this.getType(v)))).join(' | ')
                    : 'string';
            default:
                if (schemaObject.oneOf && schemaObject.oneOf.length) {
                    return schemaObject.oneOf.map(item => this.getType(item, namespace)).join(' | ');
                }
                const props = [];
                if (schemaObject.properties) {
                    Object.keys(schemaObject.properties).forEach(prop => {
                        props.push(`${prop}: ${this.getType(schemaObject.properties[prop], namespace)};`);
                    });
                }
                if (schemaObject.additionalProperties) {
                    const indexType = schemaObject.additionalProperties
                        ? schemaObject.additionalProperties === true
                            ? `{ type: 'any'; }`
                            : this.getType(schemaObject.additionalProperties, namespace)
                        : undefined;
                    if (indexType) {
                        props.push(`[key: string]: ${indexType};`);
                    }
                }
                return props.length ? `{ ${props.join(' ')} }` : 'any';
        }
    }
}
exports.ServiceGenerator = ServiceGenerator;
